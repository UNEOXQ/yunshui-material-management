#!/usr/bin/env node\n\nconst { spawn } = require('child_process');\nconst path = require('path');\nconst fs = require('fs');\n\n/**\n * æ•´åˆæ¸¬è©¦åŸ·è¡Œè…³æœ¬\n */\n\nconst DOCKER_COMPOSE_FILE = 'docker-compose.test.yml';\nconst TEST_ENV_FILE = '.env.test';\n\n/**\n * ä¸»è¦åŸ·è¡Œå‡½æ•¸\n */\nasync function runIntegrationTests() {\n  console.log('ğŸš€ Starting Integration Tests...');\n  console.log('=====================================\\n');\n  \n  try {\n    // 1. æª¢æŸ¥ç’°å¢ƒ\n    await checkEnvironment();\n    \n    // 2. å•Ÿå‹•æ¸¬è©¦æœå‹™\n    await startTestServices();\n    \n    // 3. ç­‰å¾…æœå‹™å°±ç·’\n    await waitForServices();\n    \n    // 4. åŸ·è¡Œè³‡æ–™åº«é·ç§»\n    await runMigrations();\n    \n    // 5. åŸ·è¡Œæ•´åˆæ¸¬è©¦\n    await runTests();\n    \n    console.log('\\nâœ… Integration tests completed successfully!');\n    \n  } catch (error) {\n    console.error('\\nâŒ Integration tests failed:', error.message);\n    process.exit(1);\n  } finally {\n    // 6. æ¸…ç†æ¸¬è©¦ç’°å¢ƒ\n    await cleanup();\n  }\n}\n\n/**\n * æª¢æŸ¥æ¸¬è©¦ç’°å¢ƒ\n */\nasync function checkEnvironment() {\n  console.log('ğŸ” Checking test environment...');\n  \n  // æª¢æŸ¥ Docker\n  try {\n    await runCommand('docker', ['--version']);\n    await runCommand('docker-compose', ['--version']);\n  } catch (error) {\n    throw new Error('Docker or Docker Compose not found. Please install Docker.');\n  }\n  \n  // æª¢æŸ¥æ¸¬è©¦ç’°å¢ƒæª”æ¡ˆ\n  if (!fs.existsSync(path.join('backend', TEST_ENV_FILE))) {\n    console.log('âš ï¸  Test environment file not found, creating default...');\n    await createTestEnvFile();\n  }\n  \n  console.log('âœ… Environment check passed');\n}\n\n/**\n * å‰µå»ºæ¸¬è©¦ç’°å¢ƒæª”æ¡ˆ\n */\nasync function createTestEnvFile() {\n  const testEnvContent = `# Integration Test Environment\nNODE_ENV=test\nPORT=3002\nDB_HOST=localhost\nDB_PORT=5433\nDB_NAME=yun_shui_materials_integration_test\nDB_USER=postgres\nDB_PASSWORD=test_password\nDB_SSL=false\nREDIS_HOST=localhost\nREDIS_PORT=6380\nJWT_SECRET=integration_test_jwt_secret_key_at_least_32_characters_long\nJWT_REFRESH_SECRET=integration_test_refresh_secret_key_at_least_32_characters_long\nUPLOAD_PATH=./test_uploads\nLOG_LEVEL=error\n`;\n  \n  fs.writeFileSync(path.join('backend', TEST_ENV_FILE), testEnvContent);\n  console.log('âœ… Test environment file created');\n}\n\n/**\n * å•Ÿå‹•æ¸¬è©¦æœå‹™\n */\nasync function startTestServices() {\n  console.log('ğŸ³ Starting test services...');\n  \n  // å‰µå»ºæ¸¬è©¦ç”¨çš„ docker-compose æª”æ¡ˆ\n  await createTestDockerCompose();\n  \n  // å•Ÿå‹•æœå‹™\n  await runCommand('docker-compose', ['-f', DOCKER_COMPOSE_FILE, 'up', '-d']);\n  \n  console.log('âœ… Test services started');\n}\n\n/**\n * å‰µå»ºæ¸¬è©¦ç”¨çš„ Docker Compose æª”æ¡ˆ\n */\nasync function createTestDockerCompose() {\n  const dockerComposeContent = `version: '3.8'\n\nservices:\n  test-database:\n    image: postgres:15-alpine\n    container_name: yun-shui-test-db\n    environment:\n      POSTGRES_DB: yun_shui_materials_integration_test\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: test_password\n    ports:\n      - \"5433:5432\"\n    volumes:\n      - test_postgres_data:/var/lib/postgresql/data\n      - ./database/init:/docker-entrypoint-initdb.d\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U postgres -d yun_shui_materials_integration_test\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  test-redis:\n    image: redis:7-alpine\n    container_name: yun-shui-test-redis\n    ports:\n      - \"6380:6379\"\n    volumes:\n      - test_redis_data:/data\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\nvolumes:\n  test_postgres_data:\n  test_redis_data:\n`;\n  \n  fs.writeFileSync(DOCKER_COMPOSE_FILE, dockerComposeContent);\n}\n\n/**\n * ç­‰å¾…æœå‹™å°±ç·’\n */\nasync function waitForServices() {\n  console.log('â³ Waiting for services to be ready...');\n  \n  // ç­‰å¾…è³‡æ–™åº«å°±ç·’\n  await waitForService('test-database', 'Database');\n  \n  // ç­‰å¾… Redis å°±ç·’\n  await waitForService('test-redis', 'Redis');\n  \n  console.log('âœ… All services are ready');\n}\n\n/**\n * ç­‰å¾…ç‰¹å®šæœå‹™å°±ç·’\n */\nasync function waitForService(serviceName, displayName) {\n  const maxRetries = 30;\n  let retries = 0;\n  \n  while (retries < maxRetries) {\n    try {\n      const result = await runCommand('docker-compose', [\n        '-f', DOCKER_COMPOSE_FILE,\n        'exec', '-T', serviceName,\n        'sh', '-c', 'exit 0'\n      ], { stdio: 'pipe' });\n      \n      if (result.code === 0) {\n        console.log(`âœ… ${displayName} is ready`);\n        return;\n      }\n    } catch (error) {\n      // Service not ready yet\n    }\n    \n    retries++;\n    console.log(`â³ Waiting for ${displayName}... (${retries}/${maxRetries})`);\n    await sleep(2000);\n  }\n  \n  throw new Error(`${displayName} failed to start after ${maxRetries} retries`);\n}\n\n/**\n * åŸ·è¡Œè³‡æ–™åº«é·ç§»\n */\nasync function runMigrations() {\n  console.log('ğŸ—„ï¸  Running database migrations...');\n  \n  try {\n    await runCommand('npm', ['run', 'migrate:up'], {\n      cwd: path.join(process.cwd(), 'backend'),\n      env: { ...process.env, NODE_ENV: 'test' }\n    });\n    console.log('âœ… Database migrations completed');\n  } catch (error) {\n    console.log('âš ï¸  Migration failed, but continuing with tests...');\n  }\n}\n\n/**\n * åŸ·è¡Œæ¸¬è©¦\n */\nasync function runTests() {\n  console.log('ğŸ§ª Running integration tests...');\n  \n  const testTypes = [\n    { name: 'API Integration Tests', pattern: 'integration/*.test.ts' },\n    { name: 'E2E Tests', pattern: 'e2e/*.test.ts' },\n    { name: 'System Integration Tests', pattern: 'integration/system.*.test.ts' }\n  ];\n  \n  for (const testType of testTypes) {\n    console.log(`\\nğŸ“‹ Running ${testType.name}...`);\n    \n    try {\n      await runCommand('npx', [\n        'jest',\n        '--config', 'jest.integration.config.js',\n        '--testPathPattern', testType.pattern,\n        '--verbose'\n      ], {\n        cwd: path.join(process.cwd(), 'backend'),\n        env: { ...process.env, NODE_ENV: 'test' }\n      });\n      \n      console.log(`âœ… ${testType.name} passed`);\n    } catch (error) {\n      throw new Error(`${testType.name} failed`);\n    }\n  }\n}\n\n/**\n * æ¸…ç†æ¸¬è©¦ç’°å¢ƒ\n */\nasync function cleanup() {\n  console.log('\\nğŸ§¹ Cleaning up test environment...');\n  \n  try {\n    // åœæ­¢ä¸¦ç§»é™¤æ¸¬è©¦æœå‹™\n    await runCommand('docker-compose', ['-f', DOCKER_COMPOSE_FILE, 'down', '-v']);\n    \n    // ç§»é™¤æ¸¬è©¦æª”æ¡ˆ\n    if (fs.existsSync(DOCKER_COMPOSE_FILE)) {\n      fs.unlinkSync(DOCKER_COMPOSE_FILE);\n    }\n    \n    console.log('âœ… Cleanup completed');\n  } catch (error) {\n    console.error('âš ï¸  Cleanup failed:', error.message);\n  }\n}\n\n/**\n * åŸ·è¡Œå‘½ä»¤\n */\nfunction runCommand(command, args, options = {}) {\n  return new Promise((resolve, reject) => {\n    const child = spawn(command, args, {\n      stdio: options.stdio || 'inherit',\n      cwd: options.cwd || process.cwd(),\n      env: options.env || process.env\n    });\n    \n    child.on('close', (code) => {\n      if (code === 0) {\n        resolve({ code });\n      } else {\n        reject(new Error(`Command failed with exit code ${code}`));\n      }\n    });\n    \n    child.on('error', (error) => {\n      reject(error);\n    });\n  });\n}\n\n/**\n * å»¶é²å‡½æ•¸\n */\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// åŸ·è¡Œæ¸¬è©¦\nif (require.main === module) {\n  runIntegrationTests().catch(error => {\n    console.error('Fatal error:', error);\n    process.exit(1);\n  });\n}\n\nmodule.exports = { runIntegrationTests };"